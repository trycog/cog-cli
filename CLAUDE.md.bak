## Prompt Sync

The agent prompt (`priv/prompts/PROMPT.md`) is the source of truth for what gets deployed to end users via `cog init`. It lives in this repo so it is version-aligned with the CLI.

**When you change the CLI, check whether PROMPT.md needs updating.** This file describes the workflows agents use ‚Äî if the tools change, the docs must match. Specifically:

- **Adding/removing/renaming a CLI command** ‚Äî update PROMPT.md
- **Changing the memory workflow or lifecycle** ‚Äî update the Memory System section in PROMPT.md

Tool schemas (names, descriptions, parameters) are discovered dynamically via MCP ‚Äî no static tool tables to maintain.

If your change is purely internal (refactoring, performance, bug fix with no interface change), no prompt update is needed.

## Release Process

When the user says "release" (or similar), follow this procedure:

### 1. Determine the version

- If the user specifies a version, use it.
- Otherwise, analyze all commits since the last release tag (`git log <last-tag>..HEAD --oneline`) and apply [Semantic Versioning](https://semver.org/):
  - **patch** (0.0.x): bug fixes, build fixes, documentation, dependency updates
  - **minor** (0.x.0): new features, new commands, non-breaking enhancements
  - **major** (x.0.0): breaking changes to CLI interface, config format, or public API

### 2. Update version strings

Both files must be updated to the new version:
- `build.zig` ‚Äî `const version = "X.Y.Z";`
- `build.zig.zon` ‚Äî `.version = "X.Y.Z",`

### 3. Update CHANGELOG.md

Follow [Keep a Changelog](https://keepachangelog.com/en/1.1.0/):
- Add a new `## [X.Y.Z] - YYYY-MM-DD` section below `## [Unreleased]` (or below the header if no Unreleased section exists)
- Categorize changes under: Added, Changed, Deprecated, Removed, Fixed, Security
- Add a link reference at the bottom: `[X.Y.Z]: https://github.com/trycog/cog-cli/releases/tag/vX.Y.Z`
- Each entry should be a concise, user-facing description (not a commit message)

### 4. Commit, tag, and push

```sh
git add build.zig build.zig.zon CHANGELOG.md
git commit -m "Release X.Y.Z"
git tag vX.Y.Z
git push && git push origin vX.Y.Z
```

The GitHub Actions release workflow handles the rest: building binaries, creating the GitHub Release, and updating the Homebrew tap.

## CLI Design Language

The Cog CLI has a distinctive visual identity. All terminal output follows these conventions.

### Brand

- **Logo**: "COG" spelled with Unicode box-drawing characters (‚îå ‚îê ‚îî ‚îò ‚îÄ ‚îÇ) ‚Äî see `tui.header()`
- **Tagline**: "Memory for AI agents" in dim text below the logo
- **Primary color**: Cyan (`\x1B[36m`) ‚Äî the brand accent, used for the logo, section headers, interactive glyphs, and structural elements

### Visual Hierarchy (3 levels)

1. **Bold** (`\x1B[1m`) ‚Äî primary content: command names, selected items, key labels
2. **Normal** (no style) ‚Äî standard body text
3. **Dim** (`\x1B[2m`) ‚Äî secondary content: descriptions, hints, separators, footers

Section headers combine cyan + bold for maximum contrast: `\x1B[36m\x1B[1m`.

### Spacing & Layout

- **2-space indent** as the base margin for all content
- **4-space indent** for items within a section (commands, menu options)
- **Column alignment** at position 22 (from line start) for description text beside command names
- **Blank lines** between sections ‚Äî no decorative separators within help output
- **Dim horizontal rules** (`tui.separator()`) only between distinct workflow phases (e.g., between init steps)

### Interactive Glyphs

| Glyph | Code | Usage |
|-------|------|-------|
| ‚óè | `\xE2\x97\x8F` | Selected menu item (cyan) |
| ‚óã | `\xE2\x97\x8B` | Unselected menu item (dim) |
| ‚úì | `\xE2\x9C\x93` | Success/confirmation (cyan) |
| ‚úó | `\xE2\x9C\x97` | Failure/error |
| ‚ñà | `\xE2\x96\x88` | Text cursor in input fields (cyan) |

### Output Streams

- **stderr** for all TUI and branded output (help, init, menus, progress)
- **stdout** for command results (API responses, data)

### Principles

- Restrained color ‚Äî cyan is the only hue; everything else is white/gray via bold/dim
- Box-drawing characters for the logo only, not for borders or decoration elsewhere
- No emoji in CLI output
- Columns aligned with spaces, not tabs

<cog>
# Cog

You have code intelligence via Cog.

## Announce Cog Operations

Print an emoji before Cog tool calls to indicate the category:

- üîç Code: all `cog_code_*` tools
- üß† Memory: all `cog_mem_*` tools
- üêû Debug: all `cog_debug_*` tools

<cog:code>
## Code Intelligence

The code index updates automatically when files change. A file watcher detects edits, creates, deletes, and renames ‚Äî no manual re-indexing needed.

### Code Query First

**`cog_code_query` is your primary code exploration tool.** Before using Grep, Glob, file search agents, or explore agents to understand code structure ‚Äî query the index first. The index knows every symbol, definition, and reference in the project. It answers in milliseconds what file-scanning tools take seconds to find.

**Do NOT** bypass the code index by delegating to subagents that use Grep, Glob, or file search for symbol lookups. If a subagent needs code structure information, it should use `cog_code_query`, not file-scanning tools. Subagents are appropriate for: tasks beyond the index (reading file contents, analyzing logic, cross-referencing documentation), and broad index queries that return many results (see **Subagent Pattern** below).

**Do NOT** use Grep or Glob to find symbol definitions, function locations, or file structure when `cog_code_query` covers it. Fall back to Grep/Glob only when the index doesn't have what you need (e.g., searching for string literals, comments, or content that isn't a symbol).

### Query Modes

| Mode | Use for | Required params |
|------|---------|-----------------|
| `find` | Locate where a symbol is defined | `name` |
| `refs` | Find all references to a symbol | `name` |
| `symbols` | List all symbols in a specific file | `file` |

**`find` is always your first code query.** It takes a symbol name and returns the file and line where it's defined. Never guess filenames ‚Äî let `find` tell you. Only use `symbols` mode after `find` has given you the file path. Only use `refs` after you understand the definition.

**Pattern matching:** The `name` parameter supports glob patterns ‚Äî `*` (zero or more chars) and `?` (one char). Examples: `*init*` finds all symbols containing "init", `get*` finds all symbols starting with "get". Matching is case-insensitive.

**`kind` filter:** Use the `kind` parameter to filter by symbol type (function, class, method, variable, etc.). This is a structural advantage over grep ‚Äî `name=*init*, kind=function` is a one-shot precise query that grep can only approximate with regex hacks.

**File scoping:** The `file` parameter can be used with `find` and `refs` modes to scope results to a specific file. For `find`, only symbols defined in the matching file are returned. For `refs`, only references located in the matching file are shown.

### Exploration Sequence

**This sequence is mandatory. Do not skip or reorder steps.**

When you need to understand unfamiliar code:

1. **`cog_code_query` with `find`** ‚Äî locate the symbol definition by name. This tells you the file and line. **Never skip this step.**
2. **`cog_code_query` with `symbols`** ‚Äî understand the file that `find` pointed you to
3. **`cog_code_query` with `refs`** ‚Äî see how it's used across the project
4. **Read** only the lines you need ‚Äî use the line numbers from `find`/`symbols`/`refs` with `Read`'s `offset` and `limit` parameters to read a targeted window (20-30 lines) around the symbol. **Never read an entire file when the index has already told you the exact line.**

**NEVER do any of the following:**
- Guess a filename and use `symbols` mode without first using `find` to confirm the file exists
- Use Glob or file search to locate a symbol that `find` can resolve
- Jump to `Read` before the index has told you where to look
- Use `symbols` on a file path you assumed rather than one `find` returned
- Read an entire file when you only need to see a specific symbol ‚Äî use `offset` and `limit`

This sequence replaces broad file searches. You should arrive at a `Read` call knowing the exact file and line ‚Äî reading only the relevant section, not the whole file.

### Batch Exploration with `cog_code_explore`

**`cog_code_explore`** combines find + read into a single call. Pass an array of symbol queries and get back the source code snippet around each definition ‚Äî no multi-step find‚Üíread loop needed.

```json
cog_code_explore({ queries: [{ name: "init", kind: "function" }, { name: "Settings" }], context_lines: 15 })
```

Each result returns the **top match** (highest relevance score) with the code snippet. Use this when you need to see the actual source of multiple symbols. Fall back to `cog_code_query` when you need all matches, references, or file symbol listings.

### Subagent Pattern

For multi-symbol exploration, **launch a subagent** instead of dumping all results into the main context.

- **Direct inline calls:** Single-symbol lookups with `find` or up to ~3 symbols with `cog_code_explore` ‚Äî small, focused results go straight into your context
- **Subagent calls:** Broad searches (glob patterns, 4+ symbols, or any query where you expect many results). The subagent uses `cog_code_explore` for batch find+read, then `cog_code_query` for refs/symbols as needed, and returns only a summary

This keeps the main context clean. The SCIP index returns results in milliseconds ‚Äî the subagent can make many queries cheaply without flooding the caller.

### Other Tools

- **`cog_code_status`** ‚Äî reports the current index state (files indexed, languages, etc.)
- **Do not** try to index or remove files ‚Äî the watcher handles all index maintenance automatically
</cog:code>

## Memory

You also have persistent associative memory. Checking memory before work and recording after work is how you avoid repeating mistakes, surface known gotchas, and build institutional knowledge.

**Truth hierarchy:** Current code > User statements > Cog knowledge

### Announce Memory Operations

- üß† Read: `cog_mem_recall`, `cog_mem_list_short_term`
- üß† Write: `cog_mem_learn`, `cog_mem_reinforce`, `cog_mem_update`, `cog_mem_flush`

### The Memory Lifecycle

The primary agent follows four steps for every task. This is your operating procedure, not a guideline. **Subagents do not follow this lifecycle** ‚Äî see the Subagents section below.

### Active Policy Digest

- Recall before exploration.
- Record net-new knowledge when learned.
- Reinforce only high-confidence memories.
- Consolidate before final response.
- If memory tools are unavailable, continue without memory and state that clearly.

#### 1. RECALL ‚Äî before reading code

**CRITICAL: `cog_mem_recall` is an MCP tool. Call it directly ‚Äî NEVER use the Skill tool to load `cog` for recall.** The `cog` skill only loads reference documentation. All memory MCP tools (`cog_mem_recall`, `cog_mem_learn`, etc.) are available directly when memory is configured.

If `cog_mem_*` tools are missing, memory is not configured in this workspace (no brain URL in `.cog/settings.json`). In that case, run `cog init` and choose `Memory + Tools`. Do not use deprecated `cog mem:*` CLI commands.

Your first action for any task is querying Cog. Before reading source files, before exploring, before planning ‚Äî check what you already know. Do not formulate an approach before recalling. Plans made without Cog context miss known solutions and repeat past mistakes.

The recall sequence has three visible steps:

1. Print `üß† Querying Cog...` as text to the user
2. Call the `cog_mem_recall` MCP tool with a reformulated query (not the Skill tool, not Bash ‚Äî the MCP tool directly)
3. Report results: briefly tell the user what engrams Cog returned, or state "no relevant memories found"

All three steps are mandatory. The user must see step 1 and step 3 as visible text in your response.

**Reformulate your query.** Don't pass the user's words verbatim. Think: what would an engram about this be *titled*? What words would its *definition* contain? Expand with synonyms and related concepts.

| Instead of | Query with |
|------------|------------|
| `"fix auth timeout"` | `"authentication session token expiration JWT refresh lifecycle race condition"` |
| `"add validation"` | `"input validation boundary sanitization schema constraint defense in depth"` |

If Cog returns results, follow the paths it reveals and read referenced components first. If Cog is wrong, correct it with `cog_mem_update`.

#### 2. WORK + RECORD ‚Äî learn, recall, and record continuously

Work normally, guided by what Cog returned. **Recall during work, not just at the start.** When you encounter an unfamiliar concept, module, or pattern ‚Äî query Cog before exploring the codebase. If you're about to read files to figure out how something works, `cog_mem_recall` first. Cog may already have the answer. Only explore code if Cog doesn't know.

**Record any concept-shaped knowledge that Cog doesn't have.** If you produce, receive, or synthesize knowledge that has a nameable term, a definition, and potential relationships to other concepts ‚Äî and recall didn't return it ‚Äî record it immediately via `cog_mem_learn`. The source doesn't matter: code exploration, user explanation, answering a question, diagnosing a bug, or reasoning from context all qualify equally. The test is simple: *is this a concept Cog should know but doesn't?* If yes, record it now. After each learn call, briefly tell the user what concept was stored (e.g., "üß† Stored: Session Expiry Clock Skew").

**Choose the right structure:**
- Sequential knowledge (A enables B enables C) ‚Üí use `chain_to`
- Hub knowledge (A connects to B, C, D) ‚Üí use `associations`

Default to chains for dependencies, causation, and reasoning paths. Include all relationships in the single `cog_mem_learn` call.

**Predicates:**

| Predicate | Use for |
|-----------|---------|
| `leads_to` | Causal chains, sequential dependencies |
| `generalizes` | Higher-level abstractions of specific findings |
| `requires` | Hard dependencies |
| `contradicts` | Conflicting information that needs resolution |
| `related_to` | Loose conceptual association |

Prefer `chain_to` with `leads_to`/`requires` for dependencies and reasoning paths. Use `associations` with `related_to`/`generalizes` for hub concepts that connect multiple topics.

```
üß† Recording to Cog...
cog_mem_learn({
  "term": "Auth Timeout Root Cause",
  "definition": "Refresh token checked after expiry window. Fix: add 30s buffer before window closes. Keywords: session, timeout, race condition.",
  "chain_to": [
    {"term": "Token Refresh Buffer Pattern", "definition": "30-second safety margin before token expiry prevents race conditions", "predicate": "leads_to"}
  ]
})
```

**Engram quality:** Terms are 2-5 specific words ("Auth Token Refresh Timing" not "Architecture"). Definitions are 1-3 sentences covering what it is, why it matters, and keywords for search. Broad terms like "Overview" or "Architecture" pollute search results ‚Äî be specific.

#### 3. REINFORCE ‚Äî after completing work, reflect

When a unit of work is done, step back and reflect. Ask: *what's the higher-level lesson from this work?* Record a synthesis that captures the overall insight, not just the individual details you recorded during work. Then reinforce the memories you're confident in.

```
üß† Recording to Cog...
cog_mem_learn({
  "term": "Clock Skew Session Management",
  "definition": "Never calculate token expiry locally. Always use server-issued timestamps. Local clocks drift across services.",
  "associations": [{"target": "Auth Timeout Root Cause", "predicate": "generalizes"}]
})

üß† Reinforcing memory...
cog_mem_reinforce({"engram_id": "..."})
```

#### 4. CONSOLIDATE ‚Äî before your final response

Short-term memories decay in 24 hours. Before ending, review and preserve what you learned.

1. Call `cog_mem_list_short_term` MCP tool to see pending short-term memories
2. For each entry: call `cog_mem_reinforce` if valid and useful, `cog_mem_flush` if wrong or worthless
3. **Print a visible summary** at the end of your response with these two lines:
   - `üß† Cog recall:` what recall surfaced that was useful (or "nothing relevant" if it didn't help)
   - `üß† Stored to Cog:` list the concept names you stored during this session (or "nothing new" if none)

**This summary is mandatory.** It closes the memory lifecycle and shows the user Cog is working.

**Triggers:** The user says work is done, you're about to send your final response, or you've completed a sequence of commits on a topic.

### Example (abbreviated)

In the example below: `[print]` = visible text you output, `[call]` = real MCP tool call.

```
User: "Fix login sessions expiring early"

1. [print] üß† Querying Cog...
   [call]  cog_mem_recall({...})
2. [print] üß† Recording to Cog...
   [call]  cog_mem_learn({...})
3. Implement fix using code tools, then test.
4. [call]  cog_mem_list_short_term({...}) and reinforce/flush as needed.
5. Final response includes:
   [print] üß† Cog recall: ...
   [print] üß† Stored to Cog: ...
```

### Subagents

**Subagents do not perform memory operations.** The primary agent owns the memory lifecycle ‚Äî it recalls before delegating work and records after receiving results. Subagents focus exclusively on their delegated task (code exploration, testing, analysis, etc.) and return results to the primary agent, which decides what to store.

This keeps subagents lean and fast. Memory recall and recording happen at the orchestration layer, not in every worker.

### Never Store

Passwords, API keys, tokens, secrets, SSH/PGP keys, certificates, connection strings with credentials, PII. Server auto-rejects sensitive content.

---

**RECALL ‚Üí WORK+RECORD ‚Üí REINFORCE ‚Üí CONSOLIDATE.** Skipping recall wastes time rediscovering known solutions. Deferring recording loses details while they're fresh. Skipping reinforcement loses the higher-level lesson. Skipping consolidation lets memories decay within 24 hours. Every step exists because the alternative is measurably worse.

<cog:debug>
## Debugger

Print üêû before all debug tool calls.

You have a full interactive debugger via Cog. **Use it instead of adding print, console.log, logging, or any IO statements to inspect runtime state.** The debugger replaces print debugging entirely. Only fall back to IO-based inspection if the debugger is unavailable for the target language or runtime.

### When to use the debugger

Use the debugger whenever you would otherwise inject logging or print statements to understand runtime behavior. This includes:

- A program crashes or throws an exception and the error message alone doesn't explain why
- A program produces wrong output and you need to trace how values flow through the code
- You need to inspect variable state at a specific point in execution
- You need to understand which code path is actually taken at runtime
- A test fails and the assertion message doesn't reveal the root cause

Do NOT use the debugger for problems that don't require runtime inspection: compile errors, type errors, syntax errors, missing imports, configuration issues, or bugs that are obvious from reading the code.

### Two strategies

**Exception-first** ‚Äî for crashes and runtime errors. Set an exception breakpoint, run the program, and let the runtime find the crash site. Then inspect the stack trace, exception info, and variable state at that point. This requires zero prior knowledge of where the bug is.

**Hypothesis-first** ‚Äî for logic bugs where the program doesn't crash but produces wrong output. Formulate what you think is wrong ("I believe `total` is being calculated before `discount` is applied"), set targeted breakpoints at the relevant locations, run, and inspect state to confirm or refute the hypothesis.

### The debugging loop

1. **Launch** a debug session for the program or test
2. **Set breakpoints** ‚Äî exception breakpoints for crashes, line/function breakpoints for logic bugs
3. **Run** and wait for the program to hit a breakpoint
4. **Inspect** ‚Äî examine the stack trace, variable scopes, and evaluate expressions to understand the state
5. **Decide** ‚Äî either you have enough information to diagnose the bug, or set new breakpoints and continue
6. **Stop** the debug session
7. **Fix the source code** based on what you learned

### Runtime mutation

Some languages and runtimes support modifying variables and re-executing frames at runtime. Others do not ‚Äî compiled languages like Zig, Rust, and Go may not support meaningful runtime mutation. Call `cog_debug_capabilities` after launching a session to determine what the debug driver supports.

If runtime mutation is supported, you may use it to test hypotheses ‚Äî "if I change this value, does the bug disappear?" ‚Äî but always fix the source code for the actual resolution. Runtime mutation is for diagnosis, not for fixes.

If runtime mutation is not supported, the debugger is observation-only: inspect state, diagnose the problem, stop the session, then fix the source code.

### Session recovery

Debug sessions may terminate due to idle timeout. If a debug tool call fails because the session is no longer available, relaunch the session and restore your previous state ‚Äî re-set all breakpoints, exception filters, and watchpoints that were active before the session was lost.

### Cleanup

Always call `cog_debug_stop` when you are done investigating. Never leave debug sessions running.
</cog:debug>
</cog>
